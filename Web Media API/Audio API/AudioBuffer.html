<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AudioBuffer</title>
    <style>
      body {
        padding: 100px;
      }
    </style>
  </head>
  <body>
    <h1>Web AudioBuffer() API</h1>
    <hr />
    <p>
      <b>AudioBuffer API：</b>
      <br />是表示存在存储器里的短音频资产，利用AudioContext.decodeAudioData()方法从音频文件构建，或者利用 AudioContext.createBuffer()构建于原数据。一旦将其放入AudioBuffer，可以传递到一个 AudioBufferSourceNode进行播放。
    </p>
    <p>
      <b>缓存区（buffer）包含以下数据：</b>
      <br />不间断的IEEE75432位线性PCM，从-1到1的范围额定，就是说，32位的浮点缓存区的每个样本在-1.0到1.0之间。如果AudioBuffer有不同的频道，他们通常被曝存在独立的缓存区。
    </p>

    <button id="whiteNoiseBtn">Make white noise 点击发出白噪音</button>

    <script>
      {
        // 自发白噪音实例
        let ac;
        function whiteNoiseFn() {
          // 立体声 2.0(L, R)
          const channels = 2.0;

          function init() {
            ac = new (window.AudioContext || window.webkitAudioContext)();
          }

          if (!ac) {
            init();
          }

          // 以AudioContext的采样率创建一个空的两秒立体声缓冲区
          const frameCount = ac.sampleRate * 2.0;
          
          // AudioBuffer对象是一个音频专用Buffer对象，包含很多音频信息，包括：
          const buffer = new AudioBuffer({
            // duration: 2.00, // AudioBuffer.duration 音频时长 只读 返回存储在缓存区的PCM数据的时长：双精度型（单位为秒）。
            numberOfChannels: channels, // AudioBuffer.numberOfChannels 声道数量 只读 返回存储在缓存区的PCM数据的通道数：整形。
            length: frameCount, // AudioBuffer.length 只读 返回存储在缓存区的PCM数据的采样帧率：整形。
            sampleRate: ac.sampleRate, // AudioBuffer.sampleRate 采样率 只读 存储在缓存区的PCM数据的采样率：浮点数，单位为 sample/s。
          });

          /**
          AudioBuffer 对象的相关音频声道数据处理方法：
            buffer.getChannelData(0); // 获取通道数据 返回一个 Float32Array，包含了带有频道的PCM数据，由频道参数定义（有0代表第一个频道）
            buffer.copyFromChannel(); // 复制通道数据 从AudioBuffer的指定频道复制到数组终端。
            buffer.copyToChannel(); // 写入通道数据 复制样品到原数组的AudioBuffer的指定频道
          */


          // 往音频通道中 添加白噪音音频数据
          for (let channel = 0; channel < channels; channel++) {
            const channelData = buffer.getChannelData(0);
            console.log("channelData 0:", channelData);

            const channelData1 = buffer.getChannelData(1);
            console.log("channelData 1:", channelData1);

            // const channelData2 = buffer.getChannelData(2);
            // console.log("channelData 2:", channelData2);

            // This gives us the actual array that contains the data
            const nowBuffering = buffer.getChannelData(channel);

            for (let i = 0; i < frameCount; i++) {
              // Math.random() is in [0; 1.0]
              //音频流数据 nowBuffering[i]：-1.0 到 1.0之间；
              nowBuffering[i] = Math.random() * 2 - 1;
            }
          }

          //获取AudioBufferSourceNode。
          //这是要播放AudioBuffer时要使用的AudioNode
          const source = ac.createBufferSource();
          // Set the buffer in the AudioBufferSourceNode
          source.buffer = buffer;
          // Connect the AudioBufferSourceNode to the
          // destination so we can hear the sound
          source.connect(ac.destination);
          // start the source playing
          source.start();

          source.onended = () => {
            console.log("白噪音结束。");
          };
        }

        whiteNoiseBtn.onclick = () => {
          whiteNoiseFn();
        };
      }

      {
        const video = document.createElement("video");
        const ac = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = ac.createAnalyser();

        // 先加载视频文件
        video.src = "./media/202107.mp4";

        video.addEventListener("loadedmetadata", function () {
          // 当视频元数据加载完成后，连接AnalyserNode
          analyser.connect(ac.destination);

          // 获取音频数据的频率和通道数
          const bufferLength = analyser.frequencyBinCount;
          const buffer = new Uint8Array(bufferLength);

          //  console.log(ac.destination, bufferLength, buffer);

          // 使用requestAnimationFrame确保音频采样率与系统时间同步
          requestAnimationFrame(function update() {
            analyser.getByteFrequencyData(buffer);
            // 使用傅里叶变换获取频率数据后，可以处理每个频率值
            for (let i = 0; i < bufferLength; i++) {
              console.log(i, buffer[i]);
            }
            // 每一帧更新时都会调用update方法，因此可以在此继续处理其他音频数据
            // requestAnimationFrame(update);
          });
        });
      }
    </script>
  </body>
</html>
