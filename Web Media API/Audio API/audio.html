<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Audio API examples: MediaElementAudioSource()</title>
    <style>
      body {
        padding: 100px;
      }
      input[type="range"] {
        transform: rotate(-90deg);
      }
    </style>
  </head>

  <body>
    <h1>Web Audio API examples: createScriptProcessor()</h1>

    <br />
    <br />

    <input type="range" id="L" min="0" max="100" />
    <audio mute controls>
      <source src="./media/hlbb.mp3" type="audio/mp3" />
      <source src="./media/viper.ogg" type="audio/ogg" />
      <p>This demo needs a browser supporting the &lt;audio&gt; element.</p>
    </audio>
    <video mute controls width="500">
      <source src="./media/hero.mp4" type="video/mp4" />
      <p>This demo needs a browser supporting the &lt;video&gt; element.</p>
    </video>
    <input type="range" id="R" min="0" max="100" />

    <button type="button" id="button">查看音频通道数量</button>

    <button type="button" id="LBTN">静音左声道</button>
    <button type="button" id="PBTN">音频播放</button>
    <button type="button" id="RBTN">静音右声道</button>
    <script>
      {
        var audioCtx = new AudioContext();
        // var url = './media/hlbb.mp3';
        // var audio = new Audio(url);
        // const audio = document.querySelector("audio");
        const audio = document.querySelector("video");

        const L = document.querySelector("#L");
        const R = document.querySelector("#R");

        const processor = audioCtx.createScriptProcessor(2048, 1, 1);

        let source;
        let audioData = [];

        audio.addEventListener(
          "canplaythrough", // loadedmetadata
          function () {
            source = audioCtx.createMediaElementSource(audio);
            source.connect(processor);
            source.connect(audioCtx.destination);
            processor.connect(audioCtx.destination);

            audio.play();
          },
          false
        );

        // 循环PCM数据并计算平均值
        // 给定2048样本缓冲区的体积
        processor.onaudioprocess = function (evt) {
          {
            let gcd = evt.inputBuffer.getChannelData(0),
              len = gcd.length,
              total = (i = 0),
              rms;
            while (i < len) {
              total += Math.abs(gcd[i++]);
            }
            rms = Math.sqrt(total / len);

            // console.log(input, rms, rms * 100);
            L.value = rms * 100;
            R.value = rms * 100;

            // console.log(evt.inputBuffer);

            // console.log("音频通道数量：", evt.inputBuffer.numberOfChannels);
          }

          // {
          //   let left = evt.inputBuffer.getChannelData(0);
          //   let right = evt.inputBuffer.getChannelData(1);

          //   console.lg(left, right, evt.inputBuffer.getChannelData());
          //   // 对左右声道进行处理
          //   // 例如，计算音量大小
          //   for (let i = 0; i < left.length; i++) {
          //     audioData[0][i] = left[i];
          //     audioData[1][i] = right[i];
          //   }
          //   console.log(audioData);
          // }
        };

        {
          const channels = 6;
          //  以AudioContext的采样率创建一个空的两秒立体声缓冲区
          const frameCount = audioCtx.sampleRate * 2.0;
          const myArrayBuffer = audioCtx.createBuffer(
            channels,
            frameCount,
            audioCtx.sampleRate
          );

          button.onclick = function () {
            //用白噪声填充缓冲区；
            //只是-1.0和1.0之间的随机值
            for (var channel = 0; channel < channels; channel++) {
              //这为我们提供了包含数据的实际ArrayBuffer
              var nowBuffering = myArrayBuffer.getChannelData(channel);
              for (var i = 0; i < frameCount; i++) {
                //Math.random（）在[0；1.0]中
                //音频需要在[-1.0；1.0]中
                nowBuffering[i] = Math.random() * 2 - 1;
              }
            }
            console.log(myArrayBuffer.numberOfChannels);
          };
        }
      }

      {
        const audioElement = new Audio("./media/202107.mp4");
        audioElement.crossOrigin = "anonymous"; // cross-origin - if file is stored on remote server

        const audioContext = new AudioContext();

        const audioSource = audioContext.createMediaElementSource(audioElement);

        const volumeNodeL = new GainNode(audioContext);
        const volumeNodeR = new GainNode(audioContext);

        volumeNodeL.gain.value = 2;
        volumeNodeR.gain.value = 2;

        const channelsCount = 2; // or read from: 'audioSource.channelCount'

        const splitterNode = new ChannelSplitterNode(audioContext, {
          numberOfOutputs: channelsCount,
        });
        const mergerNode = new ChannelMergerNode(audioContext, {
          numberOfInputs: channelsCount,
        });

        audioSource.connect(splitterNode);

        splitterNode.connect(volumeNodeL, 0); // connect OUTPUT channel 0
        splitterNode.connect(volumeNodeR, 1); // connect OUTPUT channel 1

        volumeNodeL.connect(mergerNode, 0, 0); // connect INPUT channel 0
        volumeNodeR.connect(mergerNode, 0, 1); // connect INPUT channel 1

        mergerNode.connect(audioContext.destination);

        let isPlaying;
        function playPause() {
          // check if context is in suspended state (autoplay policy)
          if (audioContext.state === "suspended") {
            audioContext.resume();
          }

          isPlaying = !isPlaying;
          if (isPlaying) {
            audioElement.play();
          } else {
            audioElement.pause();
          }
        }

        function setBalance(val) {}

        LBTN.onclick = function () {
          volumeNodeL.gain.value = Number(!volumeNodeL.gain.value);
          console.log(volumeNodeL.gain.value);
        };

        PBTN.onclick = function () {
          playPause();
        };

        RBTN.onclick = function () {
          volumeNodeR.gain.value = Number(!volumeNodeR.gain.value);
          console.log(volumeNodeR.gain.value);
        };
      }
    </script>
  </body>
</html>
