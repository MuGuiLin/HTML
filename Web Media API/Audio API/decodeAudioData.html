<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>decodeAudioData()</title>
    <style>
      body {
        padding: 100px;
      }
    </style>
  </head>
  <body>
    <h1>通过ac.decodeAudioData()方法 将ArrayBuffer对象 转为 AudioBuffer对象</h1>
    <hr />

    <h4>本地音频文件点播</h4>
    <div>
      <input type="file" id="file" placeholder="请选择音频文件" />
      <button id="play">播放</button>
      <button id="pause">停止</button>
    </div>
    <br />

    <script>
      {
        const ac = new (window.AudioContext || window.webkitAudioContext)();

        let bufferData = null;
        let AudioBufferSourceNode = null;

        file.addEventListener("change", function () {
          const file = this.files[0];
          const fr = new FileReader();

          fr.addEventListener("load", function (e) {
            ac.decodeAudioData(
              e.target.result,
              function (buffer) {
                // playFun(buffer);  // 解码后返回的AudioBuffer对象作为播放函数的参数传入
                console.log("音乐载入完毕");
                bufferData = buffer;

                /* 写到 decodeAudioData 事件内部，当音乐加载完毕后才能执行播放和停止 */
                // 播放
                play.onclick = function () {
                  console.log("播放");
                  AudioBufferSourceNode = ac.createBufferSource(); // 必须在播放时重新创建 AudioBufferSourceNode 对象，否则会出现不能再次播放的问题
                  AudioBufferSourceNode.buffer = bufferData; // AudioBuffer数据赋值给buffer属性
                  AudioBufferSourceNode.connect(ac.destination); // 如果只是播放音频，这边就直接将AudioBufferSourceNode连接到AudioDestinationNode

                  AudioBufferSourceNode.start(0); // 开始播放音频
                  console.log("音乐状态:", ac.state);
                };

                // 停止
                pause.onclick = function () {
                  console.log("停止");
                  AudioBufferSourceNode.stop(0); // 停止播放音乐
                  console.log("音乐状态:", ac.state);
                };
              },
              function (err) {
                console.log(err);
              }
            );
          });
          fr.readAsArrayBuffer(file);
        });
      }

      {
        const video = document.createElement("video");

        const ac = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = ac.createAnalyser();

        // 先加载视频文件
        video.src = "./media/202107.mp4";

        video.addEventListener("loadedmetadata", function () {
          // 当视频元数据加载完成后，连接AnalyserNode
          analyser.connect(ac.destination);

          // 获取音频数据的频率和通道数
          const bufferLength = analyser.frequencyBinCount;
          const buffer = new Uint8Array(bufferLength);

          //  console.log(ac.destination, bufferLength, buffer);

          // 使用requestAnimationFrame确保音频采样率与系统时间同步
          requestAnimationFrame(function update() {
            analyser.getByteFrequencyData(buffer);
            // 使用傅里叶变换获取频率数据后，可以处理每个频率值
            for (let i = 0; i < bufferLength; i++) {
              console.log(i, buffer[i]);
            }
            // 每一帧更新时都会调用update方法，因此可以在此继续处理其他音频数据
            // requestAnimationFrame(update);
          });
        });
      }
    </script>
  </body>
</html>
